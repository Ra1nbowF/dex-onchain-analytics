import os
import asyncio
import aiohttp
import asyncpg
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from decimal import Decimal
import logging
import json

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration
DATABASE_URL = os.environ.get("DATABASE_URL", "postgresql://postgres:postgres@localhost:5432/dex_analytics")
MORALIS_API_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub25jZSI6IjQ1YjRmM2IyLWJlNTYtNGQ0YS1hYTgxLTg2ZjAxYjcwNjdjYiIsIm9yZ0lkIjoiNDI5MDM1IiwidXNlcklkIjoiNDQxNDM5IiwidHlwZUlkIjoiNmQxMTQ5NzMtYmIzNS00NDI5LThkNjItNjMyODYyZDBhM2E5IiwidHlwZSI6IlBST0pFY1QiLCJpYXQiOjE3MzU1NDMwMDgsImV4cCI6NDg5MTMwMzAwOH0.J4sGyKT-fG5r2wvPOW1tC4p6o7K5Pxef5pYyO9fEL8U"
MORALIS_BASE_URL = "https://deep-index.moralis.io/api/v2.2"

# BSC BTCB Token and Pool addresses
BTCB_ADDRESS = "0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c"
POOL_ADDRESS = "0x46cf1cf8c69595804ba91dfdd8d6b960c9b0a7c4"


class CompleteMoralisMonitor:
    def __init__(self):
        self.db_pool = None
        self.session = None
        self.headers = {"X-API-Key": MORALIS_API_KEY}

    async def init_db(self):
        """Initialize database connection pool and tables"""
        try:
            self.db_pool = await asyncpg.create_pool(DATABASE_URL)
            await self.create_tables()
            logger.info("Database initialized successfully")
        except Exception as e:
            logger.error(f"Database initialization failed: {e}")
            raise

    async def create_tables(self):
        """Create all necessary tables"""
        async with self.db_pool.acquire() as conn:
            # Core swaps table
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS moralis_swaps (
                    id SERIAL PRIMARY KEY,
                    transaction_hash TEXT UNIQUE,
                    block_number BIGINT,
                    block_timestamp TIMESTAMP,
                    from_address TEXT,
                    to_address TEXT,
                    wallet_address TEXT,
                    token0_address TEXT,
                    token1_address TEXT,
                    amount0_in NUMERIC(40, 18),
                    amount1_in NUMERIC(40, 18),
                    amount0_out NUMERIC(40, 18),
                    amount1_out NUMERIC(40, 18),
                    price_usd NUMERIC(20, 8),
                    value_usd NUMERIC(20, 2),
                    gas_price NUMERIC(20, 0),
                    receipt_gas_used NUMERIC(20, 0),
                    swap_type TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Token transfers
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS moralis_transfers (
                    id SERIAL PRIMARY KEY,
                    transaction_hash TEXT,
                    block_number BIGINT,
                    block_timestamp TIMESTAMP,
                    from_address TEXT,
                    to_address TEXT,
                    value NUMERIC(40, 18),
                    value_decimal NUMERIC(20, 8),
                    token_address TEXT,
                    token_name TEXT,
                    token_symbol TEXT,
                    token_decimals INT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(transaction_hash, from_address, to_address, value)
                )
            """)

            # Holder distribution
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS moralis_holders (
                    id SERIAL PRIMARY KEY,
                    token_address TEXT,
                    holder_address TEXT,
                    balance NUMERIC(40, 18),
                    balance_formatted NUMERIC(20, 8),
                    percentage_of_supply NUMERIC(10, 6),
                    holder_type TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(token_address, holder_address)
                )
            """)

            # Aggregated stats
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS moralis_stats (
                    id SERIAL PRIMARY KEY,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    total_holders INT,
                    unique_wallets INT,
                    total_volume_24h NUMERIC(20, 2),
                    total_transactions_24h INT,
                    buy_volume_24h NUMERIC(20, 2),
                    sell_volume_24h NUMERIC(20, 2),
                    unique_buyers_24h INT,
                    unique_sellers_24h INT,
                    price_usd NUMERIC(20, 8),
                    market_cap NUMERIC(20, 2),
                    fully_diluted_valuation NUMERIC(20, 2),
                    total_supply NUMERIC(40, 18),
                    circulating_supply NUMERIC(40, 18),
                    gini_coefficient NUMERIC(5, 4),
                    top10_concentration NUMERIC(10, 6),
                    top100_concentration NUMERIC(10, 6),
                    whale_count INT,
                    dolphin_count INT,
                    fish_count INT,
                    shrimp_count INT
                )
            """)

            # Wash trading detection
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS wash_trading_alerts (
                    id SERIAL PRIMARY KEY,
                    wallet_address TEXT,
                    detection_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    round_trip_count INT,
                    total_volume NUMERIC(20, 2),
                    time_window_hours INT,
                    confidence_score NUMERIC(5, 2),
                    suspicious_pairs TEXT[],
                    details JSONB
                )
            """)

            # PnL tracking
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS wallet_pnl (
                    wallet_address TEXT PRIMARY KEY,
                    total_bought NUMERIC(40, 18),
                    total_sold NUMERIC(40, 18),
                    avg_buy_price NUMERIC(20, 8),
                    avg_sell_price NUMERIC(20, 8),
                    realized_pnl NUMERIC(20, 2),
                    unrealized_pnl NUMERIC(20, 2),
                    current_balance NUMERIC(40, 18),
                    first_transaction TIMESTAMP,
                    last_transaction TIMESTAMP,
                    transaction_count INT,
                    is_profitable BOOLEAN,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

    async def init_session(self):
        """Initialize aiohttp session"""
        self.session = aiohttp.ClientSession(headers=self.headers)

    async def close(self):
        """Clean up resources"""
        if self.session:
            await self.session.close()
        if self.db_pool:
            await self.db_pool.close()

    async def fetch_swaps(self, limit: int = 100) -> List[Dict]:
        """Fetch recent swaps for the pool"""
        try:
            url = f"{MORALIS_BASE_URL}/pairs/{POOL_ADDRESS}/events"
            params = {"chain": "bsc", "limit": limit}

            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    swaps = data.get("result", [])
                    logger.info(f"Fetched {len(swaps)} swaps")
                    return swaps
                else:
                    logger.warning(f"Swaps API returned {response.status}")
                    return []
        except Exception as e:
            logger.error(f"Error fetching swaps: {e}")
            return []

    async def fetch_token_transfers(self, limit: int = 100) -> List[Dict]:
        """Fetch recent token transfers"""
        try:
            url = f"{MORALIS_BASE_URL}/erc20/{BTCB_ADDRESS}/transfers"
            params = {"chain": "bsc", "limit": limit, "order": "DESC"}

            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    # Handle both direct array and wrapped result
                    if isinstance(data, dict):
                        transfers = data.get("result", [])
                    else:
                        transfers = data if isinstance(data, list) else []
                    logger.info(f"Fetched {len(transfers)} transfers")
                    return transfers
                else:
                    text = await response.text()
                    logger.warning(f"Transfers API returned {response.status}: {text[:200]}")
                    return []
        except Exception as e:
            logger.error(f"Error fetching transfers: {e}")
            return []

    async def fetch_top_holders(self, limit: int = 100) -> List[Dict]:
        """Fetch top token holders"""
        try:
            url = f"{MORALIS_BASE_URL}/erc20/{BTCB_ADDRESS}/owners"
            params = {"chain": "bsc", "limit": limit}

            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    holders = data.get("result", [])
                    logger.info(f"Fetched {len(holders)} holders")
                    return holders
                else:
                    logger.warning(f"Holders API returned {response.status}")
                    return []
        except Exception as e:
            logger.error(f"Error fetching holders: {e}")
            return []

    async def fetch_token_price(self) -> Dict:
        """Fetch current token price"""
        try:
            url = f"{MORALIS_BASE_URL}/erc20/{BTCB_ADDRESS}/price"
            params = {"chain": "bsc"}

            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return {}
        except Exception as e:
            logger.error(f"Error fetching price: {e}")
            return {}

    async def fetch_token_metadata(self) -> List[Dict]:
        """Fetch token metadata"""
        try:
            url = f"{MORALIS_BASE_URL}/erc20/metadata"
            params = {"chain": "bsc", "addresses": [BTCB_ADDRESS]}

            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return []
        except Exception as e:
            logger.error(f"Error fetching metadata: {e}")
            return []

    async def store_swaps(self, swaps: List[Dict]):
        """Store swap data"""
        if not swaps:
            return

        async with self.db_pool.acquire() as conn:
            for swap in swaps:
                try:
                    # Parse timestamp
                    block_timestamp = swap.get("blockTimestamp", "")
                    if block_timestamp:
                        try:
                            block_dt = datetime.fromisoformat(block_timestamp.replace("Z", "+00:00"))
                        except:
                            block_dt = datetime.utcnow()
                    else:
                        block_dt = datetime.utcnow()

                    # Determine swap type
                    amount0_in = Decimal(str(swap.get("amount0In", 0)))
                    amount1_in = Decimal(str(swap.get("amount1In", 0)))
                    swap_type = "buy" if amount0_in > 0 else "sell"

                    await conn.execute("""
                        INSERT INTO moralis_swaps (
                            transaction_hash, block_number, block_timestamp,
                            from_address, to_address, wallet_address,
                            token0_address, token1_address,
                            amount0_in, amount1_in, amount0_out, amount1_out,
                            price_usd, value_usd, gas_price, receipt_gas_used, swap_type
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
                        ON CONFLICT (transaction_hash) DO NOTHING
                    """,
                        swap.get("transactionHash"),
                        swap.get("blockNumber", 0),
                        block_dt,
                        swap.get("from"),
                        swap.get("to"),
                        swap.get("walletAddress", swap.get("from")),
                        swap.get("token0", {}).get("address"),
                        swap.get("token1", {}).get("address"),
                        amount0_in,
                        amount1_in,
                        Decimal(str(swap.get("amount0Out", 0))),
                        Decimal(str(swap.get("amount1Out", 0))),
                        Decimal(str(swap.get("priceUsd", 0))),
                        Decimal(str(swap.get("valueUsd", 0))),
                        Decimal(str(swap.get("gasPrice", 0))),
                        Decimal(str(swap.get("receiptGasUsed", 0))),
                        swap_type
                    )
                except Exception as e:
                    logger.error(f"Error storing swap: {e}")

    async def store_transfers(self, transfers: List[Dict]):
        """Store transfer data"""
        if not transfers:
            return

        async with self.db_pool.acquire() as conn:
            for transfer in transfers:
                try:
                    # Parse timestamp
                    block_timestamp = transfer.get("block_timestamp", "")
                    if block_timestamp:
                        try:
                            block_dt = datetime.fromisoformat(block_timestamp.replace("Z", "+00:00"))
                        except:
                            block_dt = datetime.utcnow()
                    else:
                        block_dt = datetime.utcnow()

                    # Get decimal value
                    value_decimal = Decimal(str(transfer.get("value_decimal", 0)))
                    if value_decimal == 0 and transfer.get("value"):
                        # Calculate from raw value if decimal not provided
                        decimals = transfer.get("token_decimals", 18)
                        value_decimal = Decimal(str(transfer.get("value", 0))) / Decimal(10 ** decimals)

                    await conn.execute("""
                        INSERT INTO moralis_transfers (
                            transaction_hash, block_number, block_timestamp,
                            from_address, to_address, value, value_decimal,
                            token_address, token_name, token_symbol, token_decimals
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                        ON CONFLICT (transaction_hash, from_address, to_address, value) DO NOTHING
                    """,
                        transfer.get("transaction_hash"),
                        transfer.get("block_number", 0),
                        block_dt,
                        transfer.get("from_address"),
                        transfer.get("to_address"),
                        Decimal(str(transfer.get("value", 0))),
                        value_decimal,
                        transfer.get("address", BTCB_ADDRESS),
                        transfer.get("token_name", "BTCB"),
                        transfer.get("token_symbol", "BTCB"),
                        transfer.get("token_decimals", 18)
                    )
                except Exception as e:
                    logger.error(f"Error storing transfer: {e}")

    async def store_holders(self, holders: List[Dict], total_supply: Decimal = None):
        """Store holder data"""
        if not holders:
            return

        async with self.db_pool.acquire() as conn:
            for holder in holders:
                try:
                    balance = Decimal(str(holder.get("balance", 0)))

                    # Calculate formatted balance
                    balance_formatted = balance / Decimal(10 ** 18)

                    # Calculate percentage if total supply provided
                    if total_supply and total_supply > 0:
                        percentage = (balance / total_supply) * 100
                    else:
                        percentage = Decimal(holder.get("percentage_relative_to_total_supply", 0))

                    # Determine holder type based on balance
                    if balance_formatted > 100:
                        holder_type = "whale"
                    elif balance_formatted > 10:
                        holder_type = "dolphin"
                    elif balance_formatted > 1:
                        holder_type = "fish"
                    else:
                        holder_type = "shrimp"

                    await conn.execute("""
                        INSERT INTO moralis_holders (
                            token_address, holder_address,
                            balance, balance_formatted,
                            percentage_of_supply, holder_type
                        ) VALUES ($1, $2, $3, $4, $5, $6)
                        ON CONFLICT (token_address, holder_address)
                        DO UPDATE SET
                            balance = EXCLUDED.balance,
                            balance_formatted = EXCLUDED.balance_formatted,
                            percentage_of_supply = EXCLUDED.percentage_of_supply,
                            holder_type = EXCLUDED.holder_type,
                            timestamp = CURRENT_TIMESTAMP
                    """,
                        BTCB_ADDRESS,
                        holder.get("owner_address"),
                        balance,
                        balance_formatted,
                        min(percentage, Decimal("100")),  # Cap at 100%
                        holder_type
                    )
                except Exception as e:
                    logger.error(f"Error storing holder: {e}")

    async def calculate_stats(self):
        """Calculate and store aggregated statistics"""
        async with self.db_pool.acquire() as conn:
            try:
                # Get 24h stats
                now = datetime.utcnow()
                day_ago = now - timedelta(hours=24)

                # Get swap stats
                swap_stats = await conn.fetchrow("""
                    SELECT
                        COUNT(*) as total_transactions,
                        SUM(value_usd) as total_volume,
                        SUM(CASE WHEN swap_type = 'buy' THEN value_usd ELSE 0 END) as buy_volume,
                        SUM(CASE WHEN swap_type = 'sell' THEN value_usd ELSE 0 END) as sell_volume,
                        COUNT(DISTINCT CASE WHEN swap_type = 'buy' THEN wallet_address END) as unique_buyers,
                        COUNT(DISTINCT CASE WHEN swap_type = 'sell' THEN wallet_address END) as unique_sellers
                    FROM moralis_swaps
                    WHERE block_timestamp > $1
                """, day_ago)

                # Get holder stats
                holder_stats = await conn.fetchrow("""
                    SELECT
                        COUNT(*) as total_holders,
                        COUNT(CASE WHEN holder_type = 'whale' THEN 1 END) as whale_count,
                        COUNT(CASE WHEN holder_type = 'dolphin' THEN 1 END) as dolphin_count,
                        COUNT(CASE WHEN holder_type = 'fish' THEN 1 END) as fish_count,
                        COUNT(CASE WHEN holder_type = 'shrimp' THEN 1 END) as shrimp_count,
                        SUM(percentage_of_supply) FILTER (WHERE holder_address IN (
                            SELECT holder_address FROM moralis_holders
                            ORDER BY balance DESC LIMIT 10
                        )) as top10_concentration,
                        SUM(percentage_of_supply) FILTER (WHERE holder_address IN (
                            SELECT holder_address FROM moralis_holders
                            ORDER BY balance DESC LIMIT 100
                        )) as top100_concentration
                    FROM moralis_holders
                    WHERE token_address = $1
                """, BTCB_ADDRESS)

                # Get current price
                price_data = await self.fetch_token_price()
                price_usd = Decimal(str(price_data.get("usdPrice", 0)))

                # Get token metadata
                metadata = await self.fetch_token_metadata()
                token_data = metadata[0] if metadata else {}

                total_supply = Decimal(str(token_data.get("total_supply", 0))) if token_data else Decimal("21000000") * Decimal(10 ** 18)

                # Calculate Gini coefficient
                gini = await self.calculate_gini_coefficient()

                # Store aggregated stats
                await conn.execute("""
                    INSERT INTO moralis_stats (
                        total_holders, unique_wallets,
                        total_volume_24h, total_transactions_24h,
                        buy_volume_24h, sell_volume_24h,
                        unique_buyers_24h, unique_sellers_24h,
                        price_usd, market_cap, fully_diluted_valuation,
                        total_supply, circulating_supply,
                        gini_coefficient,
                        top10_concentration, top100_concentration,
                        whale_count, dolphin_count, fish_count, shrimp_count
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
                """,
                    holder_stats["total_holders"],
                    holder_stats["total_holders"],
                    swap_stats["total_volume"] or 0,
                    swap_stats["total_transactions"],
                    swap_stats["buy_volume"] or 0,
                    swap_stats["sell_volume"] or 0,
                    swap_stats["unique_buyers"] or 0,
                    swap_stats["unique_sellers"] or 0,
                    price_usd,
                    price_usd * (total_supply / Decimal(10 ** 18)),
                    price_usd * Decimal("21000000"),
                    total_supply,
                    total_supply,
                    gini,
                    holder_stats["top10_concentration"] or 0,
                    holder_stats["top100_concentration"] or 0,
                    holder_stats["whale_count"],
                    holder_stats["dolphin_count"],
                    holder_stats["fish_count"],
                    holder_stats["shrimp_count"]
                )
                logger.info("Calculated and stored aggregated stats")
            except Exception as e:
                logger.error(f"Error calculating stats: {e}")

    async def calculate_gini_coefficient(self) -> Decimal:
        """Calculate Gini coefficient from holder distribution"""
        async with self.db_pool.acquire() as conn:
            try:
                # Get all holder balances
                holders = await conn.fetch("""
                    SELECT balance_formatted
                    FROM moralis_holders
                    WHERE token_address = $1
                    ORDER BY balance_formatted ASC
                """, BTCB_ADDRESS)

                if not holders:
                    return Decimal("0.5")

                balances = [float(h["balance_formatted"]) for h in holders]
                n = len(balances)

                if n == 0:
                    return Decimal("0.5")

                # Calculate Gini coefficient
                cumsum = 0
                for i, balance in enumerate(balances):
                    cumsum += (n - i) * balance

                gini = (n + 1 - 2 * cumsum / sum(balances)) / n
                return Decimal(str(max(0, min(1, gini))))
            except Exception as e:
                logger.error(f"Error calculating Gini: {e}")
                return Decimal("0.5")

    async def detect_wash_trading(self):
        """Detect potential wash trading"""
        async with self.db_pool.acquire() as conn:
            try:
                # Look for wallets with multiple round trips in short time
                now = datetime.utcnow()
                window_start = now - timedelta(hours=24)

                suspicious = await conn.fetch("""
                    WITH round_trips AS (
                        SELECT
                            wallet_address,
                            COUNT(*) as swap_count,
                            SUM(value_usd) as total_volume,
                            COUNT(DISTINCT swap_type) as type_changes
                        FROM moralis_swaps
                        WHERE block_timestamp > $1
                        GROUP BY wallet_address
                        HAVING COUNT(*) > 4
                        AND COUNT(DISTINCT swap_type) > 1
                    )
                    SELECT * FROM round_trips
                    WHERE type_changes > 2
                """, window_start)

                for wallet in suspicious:
                    # Calculate confidence score
                    swap_count = wallet["swap_count"]
                    confidence = min(95, 50 + (swap_count - 4) * 5)

                    await conn.execute("""
                        INSERT INTO wash_trading_alerts (
                            wallet_address, round_trip_count,
                            total_volume, time_window_hours,
                            confidence_score, suspicious_pairs, details
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
                    """,
                        wallet["wallet_address"],
                        wallet["type_changes"],
                        wallet["total_volume"],
                        24,
                        Decimal(str(confidence)),
                        [POOL_ADDRESS],
                        json.dumps({"swap_count": swap_count})
                    )
                    logger.info(f"Detected potential wash trading: {wallet['wallet_address']}")
            except Exception as e:
                logger.error(f"Error detecting wash trading: {e}")

    async def update_wallet_pnl(self):
        """Update wallet PnL tracking"""
        async with self.db_pool.acquire() as conn:
            try:
                # Get current price
                price_data = await self.fetch_token_price()
                current_price = Decimal(str(price_data.get("usdPrice", 0)))

                # Calculate PnL for each wallet
                wallets = await conn.fetch("""
                    SELECT
                        wallet_address,
                        SUM(CASE WHEN swap_type = 'buy' THEN amount1_out ELSE 0 END) as total_bought,
                        SUM(CASE WHEN swap_type = 'sell' THEN amount0_in ELSE 0 END) as total_sold,
                        AVG(CASE WHEN swap_type = 'buy' THEN price_usd END) as avg_buy_price,
                        AVG(CASE WHEN swap_type = 'sell' THEN price_usd END) as avg_sell_price,
                        MIN(block_timestamp) as first_transaction,
                        MAX(block_timestamp) as last_transaction,
                        COUNT(*) as transaction_count
                    FROM moralis_swaps
                    GROUP BY wallet_address
                """)

                for wallet in wallets:
                    total_bought = wallet["total_bought"] or Decimal("0")
                    total_sold = wallet["total_sold"] or Decimal("0")
                    current_balance = total_bought - total_sold

                    # Calculate realized PnL
                    avg_buy = wallet["avg_buy_price"] or Decimal("0")
                    avg_sell = wallet["avg_sell_price"] or Decimal("0")

                    realized_pnl = (avg_sell - avg_buy) * min(total_bought, total_sold)

                    # Calculate unrealized PnL
                    if current_balance > 0 and avg_buy > 0:
                        unrealized_pnl = (current_price - avg_buy) * current_balance
                    else:
                        unrealized_pnl = Decimal("0")

                    await conn.execute("""
                        INSERT INTO wallet_pnl (
                            wallet_address, total_bought, total_sold,
                            avg_buy_price, avg_sell_price,
                            realized_pnl, unrealized_pnl,
                            current_balance, first_transaction,
                            last_transaction, transaction_count,
                            is_profitable
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
                        ON CONFLICT (wallet_address)
                        DO UPDATE SET
                            total_bought = EXCLUDED.total_bought,
                            total_sold = EXCLUDED.total_sold,
                            avg_buy_price = EXCLUDED.avg_buy_price,
                            avg_sell_price = EXCLUDED.avg_sell_price,
                            realized_pnl = EXCLUDED.realized_pnl,
                            unrealized_pnl = EXCLUDED.unrealized_pnl,
                            current_balance = EXCLUDED.current_balance,
                            last_transaction = EXCLUDED.last_transaction,
                            transaction_count = EXCLUDED.transaction_count,
                            is_profitable = EXCLUDED.is_profitable,
                            updated_at = CURRENT_TIMESTAMP
                    """,
                        wallet["wallet_address"],
                        total_bought,
                        total_sold,
                        avg_buy,
                        avg_sell,
                        realized_pnl,
                        unrealized_pnl,
                        current_balance,
                        wallet["first_transaction"],
                        wallet["last_transaction"],
                        wallet["transaction_count"],
                        (realized_pnl + unrealized_pnl) > 0
                    )
            except Exception as e:
                logger.error(f"Error updating PnL: {e}")

    async def run_monitoring_cycle(self):
        """Run one complete monitoring cycle"""
        logger.info("Starting monitoring cycle...")

        # Fetch all data types
        swaps = await self.fetch_swaps()
        transfers = await self.fetch_token_transfers()
        holders = await self.fetch_top_holders()

        # Store data
        await self.store_swaps(swaps)
        await self.store_transfers(transfers)
        await self.store_holders(holders)

        # Calculate aggregated metrics
        await self.calculate_stats()
        await self.detect_wash_trading()
        await self.update_wallet_pnl()

        # Log summary
        logger.info(f"""
            Monitoring cycle complete:
            - Swaps: {len(swaps)}
            - Transfers: {len(transfers)}
            - Holders: {len(holders)}
        """)

    async def run(self):
        """Main monitoring loop"""
        await self.init_db()
        await self.init_session()

        logger.info("Moralis Complete Monitor initialized")

        while True:
            try:
                await self.run_monitoring_cycle()
                await asyncio.sleep(60)  # Run every minute
            except Exception as e:
                logger.error(f"Error in monitoring cycle: {e}")
                await asyncio.sleep(60)


async def main():
    monitor = CompleteMoralisMonitor()
    try:
        await monitor.run()
    finally:
        await monitor.close()


if __name__ == "__main__":
    asyncio.run(main())